{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf130
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww22960\viewh11920\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Borja Rojo\
brojo@u.rochester.edu\
Partner: Daniel Saltz\
\
Contents: Graph.java, Edge.java, AdjList.java, MainTest.java\
\
NOTICE: GRAPHS ARE INDEXED AT 0. CHECK CODE COMMENTS FOR DETAILS IN MainTest.java\
\
Graph.java was my main graph class. It held 4 global variables. Two ints vertexCount and edgeCount help keep track of how many vertices and edges there are. The boolean directed keeps track of the directionality of the graph. the boolean[][] adj represents the adjacency list for our graph
\fs26 .\
	This holds most of the effective code for this lab. This ADT was simple enough to implement. Insertion had the only real case handling, and it was not that complicated to make sleek anyways.\
	One of the important things used in this lab was an iterator. The iterator was a class on t\'92s own who\'92s function was to hold two ints that allowed it to traverse the rows of the adjacency list. This was effective in being able to access the information on the adjacency list in an ordered manner, but still keep low memory usage.\
\
Edge.java was my edge class. It was very simple, just as asked for. It held two ints, each one side of an edge. The heuristic assumed was that int v is the start point and int w is the end, though on an undirected graph, these things are accounted for.\
\
AdjList.java is an interface for my private iterator within the graph class.\
\
MainTest.java holds all my testing for the graphs 9.10 and 9.62 in Weiss.}
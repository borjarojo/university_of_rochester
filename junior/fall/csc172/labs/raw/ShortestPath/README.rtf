{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf130
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Borja Rojo\
brojo@u.rochester.edu\
Partner: Daniel Saltz\
\
Contents: AdjList.java Edge.java, Graph.java, MainTest.java, Vertex.java\
\
AdjList.java, Edge.java, and Graph.java are from the previous lab as the basic classes I used to implement my Graph.\
\
MainTest.java is the main method that has my test cases that prints to the command line. Make sure to run this in eclipse by importing it, as the file paths are already reorganized by Eclipse so my code does not need to have full file paths.\
\
Vertex.java is a new class that holds a basic vertex used in the shortest path method. A vertex has a number to identify it, a distance to signify it\'92s distance from a starter node, a boolean known to signify that it\'92s smallest distance has been most definitely identified, and another Vertex p used to keep track of what vertex with a smaller distance is linked to its path.\
\
1. My previous lab is functional. It\'92s nice that it is because that means I could use it here :)\
2. I made a file format, which is quite straight forward, to be able to read in graphs. This is how it works:\
\
# - vertex count, i.e. TOTAL amount, line 1\
U or D - to signify unidirectional or directional, line 2\
#,# - <start,end> Signifies connections from one vertex to another, line 3 and rest of lines\
\'93\'94 - more paths until there are no more paths, all other lines\
\
3. The static factor method that creates a graph from a file. Throws FileNotFoundException.\
This method is actually very cool and done cleanly, as this makes it much easier to write out a graph.\
\
4.O() RUNTIME ANALYSIS\
The method contains 3 nested for loops, which leads me to believe that it is a O(n^3). Two of them depend on the vertex number, as they both run through all the vertices, and the other runs through the vertices in order to be sure to accommodate for the longest possible theoretical line for any graph; a path that crosses every point. The reality, though, is that these runtimes get smaller as they go on because the conditional evaluations have a higher and higher chance of eliminating steps that don\'92t need to be taken as more and more vertices are found to already have a known smallest distance. That, though, is completely a character of the graph. A very connected graph would have a shorter runtime in finding a short path, such as one of my custom graphs. A not-so-connected graph, like figure 9.17, would take longer.\
	The way this method works, though, is that it cuts out a vertex layer to be evaluated every iteration, so that makes it more a in integer summation, which is a faster but still O(n^2) evaluation. Theoretically, with many of the heuristics used, O(n^2) is the worst case runtime, but most of the time it will be faster. Compared to the textbook, mine with theoretically be slower, as theirs it considered O(E + V).\
5. There are examples in my test method\
6. See 4\
}
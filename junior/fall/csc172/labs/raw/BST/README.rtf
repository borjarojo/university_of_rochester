{\rtf1\ansi\ansicpg1252\cocoartf1347\cocoasubrtf570
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10320\viewh7540\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 Borja Rojo\
brojo@u.rochester.edu\
\
Partner: Daniel Saltz\
\
Contents in src: BST.java, Main.java, MyBST.java, MyTreeNode.java\
\
BST.java is an interface for my MyBST.java class, a binary search tree. \
\
Main.java is my test class.\
\
MyBST.java is a class that implements a binary search tree. \
\
NOTE: MY ENTIRE TREE IS BACKWARDS. I DON\'92T KNOW WHY, BUT I THOUGHT LEFT WAS RIGHT AND RIGHT WAS LEFT FOR MORE THAN HALF THE TIME I WAS CODING. VISUALLY, BIGGER NUMBERS GO ON THE LEFT, AND SMALLER ON THE RIGHT.\
\
This lab is the implantation of a binary search tree. Essentially all the methods in MyBST access a parallel recursive versioning the MyTreeNode class. This makes managing the recursion much simpler.\
\
insert() adds a data piece to the tree by recursively calling insert() on the proper child until the end of the tree is reached. Then a new node is created and proper references are made. I use the term \'93proper\'94 because there is a comparison made on the data of the node and the data being inserted in order to guide the data to the right spot on the tree.\
\
printPreOrder(), printInOrder(), and printPostOrder() are depth first searches that stack the print command in difference parts of the search. printPreOrder() prints the data of the node being visited before it dives into it\'92s children. printInOrder() prints the data of the node being visited in between visiting one child and the other child. printPostOrder() prints the data of the node being visited after it dives into it\'92s children.\
\
lookup() returns true if the past data is in the tree and false otherwise. This is done by traversing the tree by comparing the passed data with the nodes (as it\'92s traversing). The heuristic is that if the tree contains that data, it will be found before it gets to the leaf of the tree. It something is found, it returns true, but if it reaches the end without finding a match, it returns false.\
\
delete() is a more complicated method. It takes a data piece and finds it in the tree if it\'92s there, and then deletes it. If the node found is a leaf, it has it\'92s parent dereference it. If the node found has one child, it re-references it\'92s parent to it\'92s only child. If the node has two children, it undergoes a procedure to accurately rearrange the tree to keep an accurate order. First, it finds the RIGHTMOST member of the LEFTCHILD (my tree is backwards), then it replaces it\'92s own data with the found node\'92s data, and finally the found node is deleted.}